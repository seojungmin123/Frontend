# 함수 (function)

[1. 함수에 대해](#1-함수) <br>
[2. 함수선언문, 함수표현식](#2-함수선언문-함수표현식) <br>
[3. return](#3-return) <br>
[4. 화살표함수](#4-화살표-함수) <br>
[5. 익명함수](#5-익명함수) <br>

## 1. 함수

함수를 만드는 목적은 중복을 줄이고 재활용하기 위함

- 함수는 한번에 한 작업에만 집중하는게 좋음
- 읽기 쉽고 어떤 동작인지 알 수 있게 네이밍 하기(camelCase)
- 값을 반환해야 할 때는 항상 리턴 쓰기

```js
function sayHello(){
    console.log("Hello!");
}

sayHello(); // Hello! < 함수 호출



// 매개변수(parameter) 정의하기
function sayHello(name, age){
	console.log("Hello! my name is " + name + " and i'm " + age);
}

sayHello("jungmin", 18); // Hello! my name is jungmin and i'm 18



// 가변인수 (arguments)
// 배열 형태의 객체임.
function main(){
	console.log(arguments); // [1,2,3,4,5]
}

main(1,2,3,4,5); // [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }



// OR
// 매개변수가 없어 undefined가 뜨고(false) 마지막 true를 반환함(friend)
function sayHello(name){
	let newName = name || 'friend';
	let helloString = `Hello, ${newName}`;
	console.log(helloString);
}

sayHello(); // Hello, friend
sayHello('Jane'); // Hello, Jane



// 매개변수 default 값 설정하기
// 매개변수에 값이 없으면 기본값(friend)을 반환함.
function sayHello(name = 'friend'){
	let helloString = `Hello, ${name}`;
	console.log(helloString);
}

sayHello(); // Hello, friend
sayHello('Jane'); // Hello, Jane
```

<br>

## 2. 함수선언문, 함수표현식

**그냥 함수 선언문 쓰셈**

일단 호이스팅이란걸 알아야함

js는 인터프리터 언어라 한 줄씩 위에서 아래로 순차적으로 실행하는데

코드를 실제로 실행하기 전에 모든 변수 선언과 함수 선언을 맨 위로 미리 끌어올려 놓는다고 생각하면 됨<br>
진짜 올리는건 아니고 끌어올리는 것처럼 보이는 현상임

### 함수선언문
함수선언문은 어디서든 호출 가능 ( hoisting 호이스팅 )
```js
sayHello();

function sayHello(){
	console.log('Hello');
}
```

### 함수표현식
함수 표현식은 js가 한줄씩 읽으며 해당 코드에 도달해서야 함수가 생성됨

따라서 함수 표현식 이후에서만 호출가능
```js
let sayHello = function(){
	console.log('Hello');
}

sayHello();
```

<br>

## 3. return
function으로 작업을 처리하고 그 결과값을 return함

무언가를 return하면 function의 계산을 담당하는 코드는 return값과 같아짐

한번 return하면 function은 작동을 멈추고 결과 값 return 후 끝나버림

```js
let age = 18;
function increaseAge(myAge){
	return myAge + 1; // 18 + 1
}

age = increaseAge(age); // myAge에 인수 넣기 > return 되어 19

console.log(age); // 19


// return으로 값 반환
function add(num1, num2){
	return num1 + num2;
}

const result = add(2,3); // 2 + 3
console.log(result); // 5



function showError(){
	alert('에러가 발생했습니다.'); // 실행됨
	return;
	alert('이 코드는 절대 실행되지 않습니다.'); // 위 return에서 함수가 끝났기 때문에 실행X
}

const result = showError();
console.log(result); // undefined < 매개변수가 없어 undefined
```

<br>

## 4. 화살표 함수
기존에 쓰던 함수 식

```js
(1) 함수선언문
function 함수이름() {
  // qwer1234
}

(2) 함수표현식
let 함수이름 = function() {
  // qwer1234
}
```

화살표 함수
```js
let 함수이름 = () => {
  // qwer1234
}
```

<br>

### 일반 함수와의 차이점

### 1. 소괄호 생략 가능
파라미터가 하나라면 소괄호를 생략가능

```js
const double = x => { return x * 2 }

console.log( double(4) ); // 8
console.log( double(8) ); // 16
```
### 2. 중괄호 생략 가능
중괄호 안에 return이 한줄 뿐이라면 중괄호와 return도 생략가능

```js
const double = x =>  x * 2 ;

console.log( double(4) ); // 8
console.log( double(8) ); // 16
```

<br>

### 3. 내부에서 this값을 쓸 때 밖에 있던 this값을 그대로 사용
function 키워드로 생성한 일반 함수와 화살표 함수의 가장 큰 차이점은 this 임

<br>

### 3.1. 일반 함수의 this
함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정됨

### 3-2. 화살표 함수의 this
화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정됨

화살표 함수의 this 는 언제나 상위 스코프의 this를 가리킴

```js
const object = {
	name: '정민',
	main: function(){
		console.log(this.name);
	},
	mainArrow: ()=>{
		console.log(this.name);
	}
};
object.main(); // 정민
object.mainArrow(); // undefined (전역)
```
<br>


### 4. 화살표함수에서의 가변인수
```js
// 화살표 함수에서는 그냥 arguments하면 안되고, ...앞에 붙여야됨.

function main = (...args) => console.log(args); 
main(1,2,3,4,5); // [1,2,3,4,5]
```

<br>

## 5. 익명함수

작업시 처음 호출하는 함수로, 함수의 이름이 존재하지 않음


- **일반 함수** <br>
전역적이며, 전체가 다 호이스팅 되므로 **선언과 호출의 위치가 상관이 없음**  <br>
재사용 될 기능에 주로 사용함.

- **익명 함수** <br>
선언부만 호이스팅**되며 호출의 위치와 구현의 위치간에 순서가 알맞아야 함 <br>
함수 **선언 부분이 호출 위치 보다 위에** 있어야함

--- 
메모리 관리에 아주 효과적.

일반 함수는 자바스크립트를 초기에 읽을 때 모두 호이스팅하는데, 전체 스크립트 내에서 단 한번만 쓰이는 함수가 일반 함수로 구현되어 있다면, <br>
이 함수는 사용될 단 한번을 기다리며 불필요하게 메모리를 차지하게 됨. 즉 메모리를 낭비하게 되는 것

하지만 익명 함수를 사용할 경우 불필요한 시간동안 메모리를 차지하지 않고, <br>
해당 함수의 위치에서 함수가 구현되고 사라지면서 메모리를 아낄 수 있게 됨

**한번만 사용하는 기능을 구현할 때는 익명 함수를 주로 사용하고, 여러번 사용하는, 재사용이 필요한 함수일 때는 일반 함수로 구현**

<br>

## 6. 콜백함수

함수에 파라미터(매개변수)로 들어가는 함수.

순차적으로 실행하고 싶을 때 사용함. ex) setTimeOut, addEventListener …

보통 매개변수에 함수를 전달하여 일회용으로 사용하기 때문에 익명함수 형태로 많이 사용.

배열, 메소드(), 이벤트리스너, 고차함수(forEach), Ajax 결과값, 비동기 처리, 타이머 실행함수, 애니메이션 완료 등에 사용됨

- 이미 만들어진 함수도 콜백함수로 넣을 수 있음.
- 함수명 작명 가능.
- 콜백함수가 필요한 함수들에만 콜백함수 사용 가능.

```js
const x = (callback) => {
    console.log(callback);                      //[Function: y]
    console.log('-----------');                 //-----------
    console.log(`값:return = ${callback()} `);  //값:return = 30  <- y함수는 여기서 실행됨
};
//값 - 함수
const y= ((x = 10, y = 20) => {
    return x + y;
});

x(y) // y함수가 인수값
```

<br>

ex) 클릭 이벤트
```js
const myButton = document.getElementById('submitButton');

// addEventListener의 두 번째 인수가 콜백 함수임
myButton.addEventListener('click', () => {
    alert('버튼이 클릭되었습니다!');
});
```

<br>

ex) 이미지 보이게 하기
```js
const pic = document.querySelector('.pic');
const url = `https://cdn.pixabay.com/photo/2023/09/30/09/12/dachshund-8285220_640.jpg`;

const loadImg = (imgUrl, callback) => {
    const img = document.createElement('img');
    img.setAttribute('src', imgUrl);
    setTimeout(() => {
        callback(img);
    }, 2000);
};
loadImg(url, (imgEl) => {
    pic.innerHTML = '';
    pic.append(imgEl);
});
```

<br>

참고
- [https://velog.io/@zunyange/JS-function-%EB%8C%80%EC%8B%A0-arrow-function%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0]
- [https://velog.io/@soshin_dev/JS-%EC%9D%BC%EB%B0%98-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%B5%EB%AA%85-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90]
- [https://velog.io/@rkio/Javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85hoisting%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC]
- [https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Functions]